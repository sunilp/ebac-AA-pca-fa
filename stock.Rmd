---
title: "Stock Analysis"
author: "Gaelan Gu, Sunil Prakash, Rose Wang Ruoshi, Yolanda Yu Yue"
date: "11/02/2017"
output: md_document
---

1 - Objective
----------------

This is a PCA analysis of stock prices in various Chinese stock markets... (to be elaborated)

2 - Implementation
----------------

### Importing Stock Price Dataset
```{r}
stock = read.csv('stkpc_analysis.csv')
#summary(stock)
```

### Principal Component Analysis
```{r}
#stock_pca = princomp(stock[, -1])
#summary(stock_pca)

pca <- prcomp(stock[2:17],center = TRUE, scale. =TRUE)
pca2 <-  prcomp(stock[2:17]) #without scaling
summary(pca)


print(pca)
```
We can determine from the summary that the first 4 principal components (PCs) are sufficient to explain the variance in the variables - 99% to be precise.

Let us visualize this discovery using a scree plot below.

### Scree Plot 
```{r}
screeplot(pca, type = 'l',
          main = 'PCA on Stock Price')
```

As it can be clearly seen in the scree plot, the first 2 PCs explain most of the variability as there is a sharp kink at PC3 when the line begins to straighten on the chart.

### Biplot with *ggbiplot* package
```{r}
library(ggbiplot)
s = ggbiplot(pca2, obs.scale = 1, var.scale = 1, 
             ellipse = T, circle = T)
print(s + coord_cartesian(xlim = c(-200, 200), ylim = c(-200, 200)))
```

### clustering

```{r}

library(devtools)
#install_github("ggbiplot", "vqv")
 
stock_price <- stock[,1]

stock_category <- lapply(stock_price, function(price){
  if(price <= 20){
    return("LOW")
  }else if(price > 20 &  price <= 40 ){
    return ("NORMAL")
  }else if(price > 40  &  price <= 55 ){
    return ("HIGH")
  }else if( price > 55 ){
    return ("V.HIGH")
  }else {
    print("some garbage")
    print(price)
    return(NA)
  }
})

stock_category <- as.factor(unlist(stock_category))

hist(stock_price)

library(ggbiplot)
g <- ggbiplot(pca, obs.scale = 1, var.scale = 1, 
              groups = stock_category, ellipse = TRUE, 
              circle = TRUE)

g <- g + scale_color_discrete(name = '')
g <- g + theme(legend.direction = 'horizontal', 
               legend.position = 'top')
print(g)

```
### biplot

```{r}
biplot(pca, scale = TRUE, expand = 2)
	
```


#### Selecting Princial Components
```{r}

ev <- pca$sdev^2

print(ev)
```

Here, till 6 components , eigen values are >1, so will discard others.


### Regression Analysis with PCA components
```{r}
# install.packages('caTools')
stock.re <- data.frame(pca$x)
fit1<- lm(stock_price ~ stock.re$PC1 + stock.re$PC2 + stock.re$PC3 + stock.re$PC4 + stock.re$PC5 + stock.re$PC6, data=stock.re)
summary(fit1)

```

Lets visualize it

```{r}

plot(fit1)


```


### Cluster Analysis foe components

#### Analysing the components (taking 6 PC)
```{r} 
plot(stock.re[1:6], pch=16, col=rgb(0,0,0,0.5))
```

 Here are twelve 2-D projections of data which are in a 6-D space. You can see there’s a clear outlier in all the dimensions, as well as some bunching together in the different projections.
 
 Lets visualize in 3d space
 
```{r}
library(rgl)
# Multi 3D plot
comp <- stock.re[1:6]
plot3d(comp$PC1, comp$PC2, comp$PC3)
plot3d(comp$PC4, comp$PC5, comp$PC6)
plot3d(comp$PC1, comp$PC3, comp$PC4)
```

#### K-mean Clustering

```{r}
# Determine number of clusters
wss <- (nrow(stock)-1)*sum(apply(stock,2,var))
for (i in 2:16) wss[i] <- sum(kmeans(stock,centers=i)$withinss)
plot(1:16, wss, type="b", xlab="Number of Clusters",ylab="Within groups sum of squares")
```
So here we can see that the “elbow” in the scree plot is at k=5, so we apply the k-means clustering function with k = 5 and plot.

```{r}
# Apply k-means with k=5
k <- kmeans(comp, 5, nstart=25, iter.max=1000)
library(RColorBrewer)
library(scales)
palette(alpha(brewer.pal(9,'Set1'), 0.5))
plot(comp, col=k$clust, pch=16)

```
Here, few outliers, with 2 ans 3. Lets visualize with 3d plot

```{r}
plot3d(comp$PC1, comp$PC2, comp$PC3, col=k$clust)
plot3d(comp$PC4, comp$PC5, comp$PC6, col=k$clust)
```

#### Naming the clusters

```{r}
#Sorting based on cluster sizes
sort(table(k$clust))
clust <- names(sort(table(k$clust)))

print(clust)

```


Generate report
rmarkdown::render(
  input="stock.Rmd", 
  output_format="md_document", 
  output_file="README.md"
) 

